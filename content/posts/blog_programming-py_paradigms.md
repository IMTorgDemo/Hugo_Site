
+++
title = "Programming for Balancing Short- and Long-Term Needs"
date = "2021-12-14"
author = "Jason Beach"
categories = ["Innovation", "Computer_Science_and_Programming"]
tags = ["programming_paradigms", "engineering"]
+++


Software engineering is all about design and balancing requirements.  Anyone can learn syntax and how to code, but there are so many challenges to scaling as the codebase grows.  Some aspects to balance include delivering functionality vs code debt, deploying solutions vs preferred architecture, and countless others.  In addition, developers need to not only understand and keep updated on the language, but also the ecosystem of libraries and tools, underlying data structures and algorithms, and also design patterns.  These skills discriminate between an inexperience coder and a veteran engineer.

This is a ladder of skills in employing a language:

* syntax and programming paradigm
* idioms and best practices
* popular modules
* documentation and testing
* IDE and auxiliary tools
* syntax edge cases (`wtf python`)
* underlying data structures and algorithms
* design patterns
* architectural patterns
* customer relations

Aspects to balance in user story, issue development and prioritization for short- / long-term requirements.  These are _loosely_ ordered in how they typically manifest during a project, and often re-cycle as a loop of concerns.

* proof of concept
* oop design
* minimum viable product
* deployment automation
* speed of functionality delivery
* documentation
* codebase organization
* testing and code coverage
* microservice decomposition

It would be great to do some empirical analysis on these assumptions using [ScrumSaga](www.scrumsaga.com).
